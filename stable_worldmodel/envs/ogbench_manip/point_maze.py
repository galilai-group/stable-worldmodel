"""OGBench Point Maze environment with variation_space support.

This module wraps the OGBench point maze environment (and variants such as
BallMaze or AntMaze) with a ``variation_space`` for visual domain
randomization.

The variation mechanism follows the same ``modify_mjcf_model`` /
``compile_model`` / ``mark_dirty`` pattern used by the dm_control wrappers
(e.g. ``CheetahDMControlWrapper``):

1. The maze XML (already containing the maze walls generated by OGBench's
   ``update_tree``) is loaded into a dm_control MJCF model after the base
   env is constructed.
2. On each :meth:`reset`, :meth:`modify_mjcf_model` applies the current
   variation values to the MJCF model and calls :meth:`mark_dirty` if
   anything changed.
3. If the model is dirty, :meth:`compile_model` exports the modified MJCF
   to a temporary file, creates a new ``mujoco.MjModel`` / ``mujoco.MjData``
   from it, replaces the model/data on the wrapped env in-place, and
   reinstates any post-compilation setup (pixel floor encoding, renderer).

Supported visual variations:

- **agent.color** – agent sphere material RGB color.
- **wall.color** – maze wall material RGB color.
- **floor.color** – checker floor texture rgb1 / rgb2 colors, shape
  ``(2, 3)``. *Note*: for ``ob_type='pixels'`` the floor texture is
  overwritten at compile time by OGBench's position-encoding gradient when
  ``floor.pixel_encoding=1``.
- **floor.pixel_encoding** – binary toggle controlling whether OGBench's
  position-encoding floor gradient is re-applied after recompilation in
  pixel-observation mode.
- **light.intensity** – global directional light diffuse intensity.

Example::

    from stable_worldmodel.envs.ogbench_manip.point_maze import PointMazeEnv

    env = PointMazeEnv(maze_type='large', ob_type='pixels')

    # Reset and sample all visual variations.
    obs, info = env.reset(options={'variation': ['all']})

    for _ in range(200):
        action = env.action_space.sample()
        obs, reward, terminated, truncated, info = env.step(action)
        if terminated or info.get('success', 0.0) > 0:
            break

.. _OGBench:
   https://github.com/seohongpark/ogbench/
"""

import os
import tempfile

import mujoco
import numpy as np
import gymnasium as gym
from dm_control import mjcf

from ogbench.locomaze.maze import make_maze_env

from stable_worldmodel import spaces as swm_spaces


DEFAULT_VARIATIONS = ()
"""Variation keys sampled on every reset even when the caller does not
specify ``options['variation']``.

Unlike :class:`CubeEnv`, the point maze has no start/goal position
variations (those are fixed by maze topology and task definitions), so
nothing is varied by default.
"""


class PointMazeEnv(gym.Wrapper):
    """Point maze environment with variation_space support.

    Wraps the OGBench maze environment (created via
    :func:`ogbench.locomaze.maze.make_maze_env`) with a ``variation_space``
    that enables visual domain randomization.  Variation application follows
    the ``modify_mjcf_model`` / ``compile_model`` pattern of the dm_control
    wrappers in this project.

    All attributes and methods not explicitly overridden are forwarded to
    the underlying env via :class:`gymnasium.Wrapper`.

    Attributes:
        variation_space (swm_spaces.Dict): Hierarchical space defining
            variation ranges for:

            - ``agent.color``: Agent sphere RGB color, shape ``(3,)``.
            - ``wall.color``: Maze wall material RGB color, shape ``(3,)``.
            - ``floor.color``: Checker floor texture colors (rgb1 / rgb2),
              shape ``(2, 3)``.  For ``ob_type='pixels'``, this only has a
              visible effect when ``floor.pixel_encoding=0``.
            - ``floor.pixel_encoding``: Binary toggle (0/1) controlling
              whether OGBench's position-encoding floor gradient is applied
              after model recompilation in pixel-observation mode.
            - ``light.intensity``: Global directional light diffuse
              intensity scalar, shape ``(1,)``.
    """

    metadata = {'render_modes': ['rgb_array']}

    def __init__(
        self,
        loco_env_type='point',
        maze_env_type='maze',
        maze_type='large',
        ob_type='pixels',
        width=64,
        height=64,
        **kwargs,
    ):
        """Initialize PointMazeEnv.

        Creates the underlying OGBench maze environment (including maze-wall
        XML generation) and loads the resulting XML into a dm_control MJCF
        model for subsequent modification.

        Args:
            loco_env_type (str): Locomotion agent type forwarded to
                ``make_maze_env``.  One of ``'point'``, ``'ant'``,
                ``'humanoid'``.  Defaults to ``'point'``.
            maze_env_type (str): Maze task type.  Either ``'maze'`` (navigate
                to goal) or ``'ball'`` (push a ball to goal).  Defaults to
                ``'maze'``.
            maze_type (str): Maze layout.  One of ``'arena'``, ``'medium'``,
                ``'large'``, ``'giant'``, ``'teleport'``.  Defaults to
                ``'large'``.
            ob_type (str): Observation type forwarded to ``make_maze_env``.
                Either ``'states'`` or ``'pixels'``.  Defaults to
                ``'pixels'`` so that ``info['goal']`` is a rendered image
                compatible with the SWM wrapper stack.
            width (int): Renderer width in pixels, forwarded to
                ``make_maze_env``.  Defaults to ``64`` to match OGBench's
                hardcoded ``observation_space`` shape ``(64, 64, 3)``.
            height (int): Renderer height in pixels, forwarded to
                ``make_maze_env``.  Defaults to ``64`` for the same reason.
            **kwargs: Additional keyword arguments forwarded to
                ``make_maze_env`` (e.g. ``reward_task_id``, ``render_mode``).
        """
        env = make_maze_env(
            loco_env_type=loco_env_type,
            maze_env_type=maze_env_type,
            maze_type=maze_type,
            ob_type=ob_type,
            width=width,
            height=height,
            **kwargs,
        )
        super().__init__(env)

        # Load the maze XML (already containing walls generated by OGBench's
        # update_tree) into a dm_control MJCF model for later modification.
        self._mjcf_model = mjcf.from_path(self.env.fullpath)
        self._dirty = False
        self._mjcf_tempdir = None
        # OGBench enables pixel floor encoding at construction time for
        # pixel observations.
        self._pixel_encoding_runtime_state = (
            1 if self.env._ob_type == 'pixels' else None
        )

        # Read initial variation values from the MJCF model so that
        # init_value faithfully represents the "no variation" baseline.
        self_mat = self._mjcf_model.find('material', 'self')
        wall_mat = self._mjcf_model.find('material', 'wall')
        global_light = self._mjcf_model.find('light', 'global')
        grid_tex = self._mjcf_model.find('texture', 'grid')

        agent_color_default = (
            np.array(self_mat.rgba[:3], dtype=np.float64)
            if self_mat.rgba is not None
            else np.array([0.7, 0.5, 0.3], dtype=np.float64)
        )
        wall_color_default = (
            np.array(wall_mat.rgba[:3], dtype=np.float64)
            if wall_mat.rgba is not None
            else np.array([1.0, 1.0, 1.0], dtype=np.float64)
        )
        light_intensity_default = (
            float(np.mean(global_light.diffuse))
            if global_light.diffuse is not None
            else 1.0
        )
        floor_rgb1_default = (
            np.array(grid_tex.rgb1, dtype=np.float64)
            if grid_tex.rgb1 is not None
            else np.array([0.08, 0.11, 0.16], dtype=np.float64)
        )
        floor_rgb2_default = (
            np.array(grid_tex.rgb2, dtype=np.float64)
            if grid_tex.rgb2 is not None
            else np.array([0.15, 0.18, 0.25], dtype=np.float64)
        )

        self.variation_space = swm_spaces.Dict(
            {
                'agent': swm_spaces.Dict(
                    {
                        'color': swm_spaces.Box(
                            low=0.0,
                            high=1.0,
                            shape=(3,),
                            dtype=np.float64,
                            init_value=agent_color_default,
                        ),
                    }
                ),
                'wall': swm_spaces.Dict(
                    {
                        'color': swm_spaces.Box(
                            low=0.0,
                            high=1.0,
                            shape=(3,),
                            dtype=np.float64,
                            init_value=wall_color_default,
                        ),
                    }
                ),
                'floor': swm_spaces.Dict(
                    {
                        'color': swm_spaces.Box(
                            low=0.0,
                            high=1.0,
                            shape=(2, 3),
                            dtype=np.float64,
                            init_value=np.array(
                                [floor_rgb1_default, floor_rgb2_default]
                            ),
                        ),
                        'pixel_encoding': swm_spaces.Discrete(
                            n=2,
                            init_value=0,
                        ),
                    }
                ),
                'light': swm_spaces.Dict(
                    {
                        'intensity': swm_spaces.Box(
                            low=0.0,
                            high=1.0,
                            shape=(1,),
                            dtype=np.float64,
                            init_value=np.array(
                                [light_intensity_default], dtype=np.float64
                            ),
                        ),
                    }
                ),
            }
        )
        # EverythingToInfoWrapper reads `env.unwrapped.variation_space`.
        # Since `unwrapped` skips this wrapper, mirror the same object onto
        # the base OGBench MazeEnv instance.
        self.env.unwrapped.variation_space = self.variation_space

    # ------------------------------------------------------------------
    # Core reset / variation interface
    # ------------------------------------------------------------------

    def reset(self, *, seed=None, options=None):
        """Reset the environment to an initial state.

        Samples from the ``variation_space`` (if requested), applies the
        sampled values to the MJCF model via :meth:`modify_mjcf_model`, and
        recompiles the MuJoCo model via :meth:`compile_model` if anything
        changed.  Then delegates to the underlying maze env reset.

        Args:
            seed (int | None): Random seed forwarded to the underlying env
                reset.  Not used for variation sampling.
            options (dict | None): Reset options.  Forwarded to the underlying
                maze env and also supports:

                - ``'variation'``: Sequence of variation key paths to
                  resample (e.g. ``['agent.color', 'light.intensity']``).
                  Pass ``['all']`` to resample every variation.
                - ``'variation_values'``: Dict mapping variation key paths
                  to explicit values, overriding sampled values.

        Returns:
            tuple: ``(observation, info)`` from the underlying env reset.
        """
        options = options or {}

        swm_spaces.reset_variation_space(
            self.variation_space,
            seed=None,
            options=options,
            default_variations=DEFAULT_VARIATIONS,
        )

        self._mjcf_model = self.modify_mjcf_model(self._mjcf_model)
        if self._dirty:
            self.compile_model()

        obs, info = self.env.reset(seed=seed, options=options)
        info.pop('goal', None)
        return obs, info

    def modify_mjcf_model(self, mjcf_model):
        """Apply current variation values to the MJCF model.

        Mirrors the ``modify_mjcf_model`` method of the dm_control wrappers
        (e.g. :class:`CheetahDMControlWrapper`).  Compares the current MJCF
        attribute values against the variation space values and, if any differ,
        updates the MJCF and calls :meth:`mark_dirty` to schedule
        recompilation.

        Args:
            mjcf_model (mjcf.RootElement): The dm_control MJCF model to
                modify in-place.

        Returns:
            mjcf.RootElement: The (possibly modified) MJCF model.

        Note:
            The ``floor.color`` variation modifies the checker texture rgb1 /
            rgb2 values in the MJCF.  For ``ob_type='pixels'``, this has a
            visible effect only when ``floor.pixel_encoding=0`` because
            :meth:`compile_model` otherwise overwrites the floor texture with
            OGBench's position-encoding gradient.
        """
        changed = False

        # Floor color (checker texture rgb1 / rgb2).
        grid_texture = mjcf_model.find('texture', 'grid')
        desired_rgb1 = self.variation_space['floor']['color'].value[0]
        desired_rgb2 = self.variation_space['floor']['color'].value[1]
        texture_changed = grid_texture.rgb1 is None or not np.allclose(
            grid_texture.rgb1, desired_rgb1
        )
        texture_changed = texture_changed or (
            grid_texture.rgb2 is None
            or not np.allclose(grid_texture.rgb2, desired_rgb2)
        )
        grid_texture.rgb1 = desired_rgb1
        grid_texture.rgb2 = desired_rgb2
        changed = changed or texture_changed

        # Agent color.
        self_mat = mjcf_model.find('material', 'self')
        desired_rgba = np.concatenate(
            [
                self.variation_space['agent']['color'].value,
                np.array([1.0], dtype=np.float64),
            ]
        )
        agent_changed = self_mat.rgba is None or not np.allclose(
            np.asarray(self_mat.rgba, dtype=np.float64), desired_rgba
        )
        self_mat.rgba = desired_rgba
        changed = changed or agent_changed

        # Wall color.
        wall_mat = mjcf_model.find('material', 'wall')
        desired_rgba = np.concatenate(
            [
                self.variation_space['wall']['color'].value,
                np.array([1.0], dtype=np.float64),
            ]
        )
        wall_changed = wall_mat.rgba is None or not np.allclose(
            np.asarray(wall_mat.rgba, dtype=np.float64), desired_rgba
        )
        wall_mat.rgba = desired_rgba
        changed = changed or wall_changed

        # Light intensity.
        global_light = mjcf_model.find('light', 'global')
        desired_diffuse = self.variation_space['light']['intensity'].value[
            0
        ] * np.ones(3, dtype=np.float32)
        light_changed = global_light.diffuse is None or not np.allclose(
            np.asarray(global_light.diffuse, dtype=np.float32), desired_diffuse
        )
        global_light.diffuse = desired_diffuse
        changed = changed or light_changed

        # Toggling pixel floor encoding requires recompilation to either
        # restore checker texture from XML (off) or reapply gradient (on).
        if self.env._ob_type == 'pixels':
            desired_pixel_encoding = int(
                self.variation_space['floor']['pixel_encoding'].value
            )
            if desired_pixel_encoding != self._pixel_encoding_runtime_state:
                changed = True
            self._pixel_encoding_runtime_state = desired_pixel_encoding

        if changed:
            self.mark_dirty()
        return mjcf_model

    def compile_model(self):
        """Recompile the MuJoCo model from the modified MJCF.

        Exports the current dm_control MJCF model to a temporary directory,
        loads a fresh ``mujoco.MjModel`` / ``mujoco.MjData`` from the
        exported XML, and replaces the model and data on the wrapped env
        in-place.

        Post-compilation steps:

        - For ``ob_type='pixels'``: re-applies OGBench's position-encoding
          gradient on the floor texture when ``floor.pixel_encoding == 1``
          and reinitialises the renderer.
        """
        if self._mjcf_tempdir is None:
            self._mjcf_tempdir = tempfile.TemporaryDirectory()

        mjcf.export_with_assets(
            self._mjcf_model,
            self._mjcf_tempdir.name,
            out_file_name='point_maze.xml',
        )
        xml_path = os.path.join(self._mjcf_tempdir.name, 'point_maze.xml')

        # Replace model and data on the wrapped env in-place.
        self.env.model = mujoco.MjModel.from_xml_path(xml_path)
        self.env.data = mujoco.MjData(self.env.model)

        # Post-compilation setup.
        if self.env._ob_type == 'pixels':
            if int(self.variation_space['floor']['pixel_encoding'].value) == 1:
                # Re-apply OGBench's position-encoding floor texture gradient.
                self._apply_pixel_floor_encoding()
            self.env.initialize_renderer()

        self._dirty = False

    def mark_dirty(self):
        """Mark the model as requiring recompilation on the next reset."""
        self._dirty = True

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------

    def _apply_pixel_floor_encoding(self):
        """Re-apply OGBench's position-encoding gradient on the floor texture.

        For ``ob_type='pixels'``, OGBench encodes the agent's 2-D position
        into the floor texture (R channel ← row index, G channel ← column
        index, B = 128).  This is performed once in ``MazeEnv.__init__`` and
        must be replicated here after each :meth:`compile_model` call because
        the freshly loaded model reverts to the XML-defined checker texture.
        """
        tex_grid = self.env.model.tex('grid')
        tex_height = int(tex_grid.height[0])
        tex_width = int(tex_grid.width[0])
        attr_name = (
            'tex_rgb' if hasattr(self.env.model, 'tex_rgb') else 'tex_data'
        )
        tex_data = getattr(self.env.model, attr_name)
        start = int(tex_grid.adr[0])
        tex_rgb = tex_data[start : start + 3 * tex_height * tex_width].reshape(
            tex_height, tex_width, 3
        )

        max_value = 192
        for x in range(tex_height):
            for y in range(tex_width):
                tex_rgb[x, y, :] = [
                    int(x / tex_height * max_value),
                    int(y / tex_width * max_value),
                    128,
                ]
